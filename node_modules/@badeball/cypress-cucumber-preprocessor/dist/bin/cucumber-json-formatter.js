#!/usr/bin/env node
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const stream_1 = __importDefault(require("stream"));
const events_1 = require("events");
const cucumber_1 = require("@cucumber/cucumber");
const message_streams_1 = require("@cucumber/message-streams");
const error_1 = require("../helpers/error");
const type_guards_1 = require("../helpers/type-guards");
const envelopes = [];
stream_1.default.pipeline(process.stdin, new message_streams_1.NdjsonToMessageStream(), new stream_1.default.Writable({
    objectMode: true,
    write(envelope, _, callback) {
        envelopes.push(envelope);
        callback();
    },
}), (err) => {
    if (err) {
        console.error(err.stack);
        process.exitCode = 1;
    }
    else {
        const eventBroadcaster = new events_1.EventEmitter();
        const eventDataCollector = new cucumber_1.formatterHelpers.EventDataCollector(eventBroadcaster);
        const stepDefinitions = envelopes
            .map((m) => m.stepDefinition)
            .filter(type_guards_1.notNull)
            .map((s) => {
            return {
                id: s.id,
                uri: "not available",
                line: 0,
            };
        });
        const log = (output) => {
            if (typeof output !== "string") {
                throw (0, error_1.createError)("Expected a JSON output of string, but got " + typeof output);
            }
            else {
                console.log(output);
            }
        };
        new cucumber_1.JsonFormatter({
            eventBroadcaster,
            eventDataCollector,
            log,
            supportCodeLibrary: {
                stepDefinitions,
            },
            colorFns: null,
            cwd: null,
            parsedArgvOptions: {},
            snippetBuilder: null,
            stream: null,
            cleanup: null,
        });
        for (const message of envelopes) {
            eventBroadcaster.emit("envelope", message);
        }
    }
});
